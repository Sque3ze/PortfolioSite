<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TrackGraph Observability — Telemetry Infrastructure</title>
  <meta name="theme-color" content="#000000" />
  <link href="../assets/css/theme.css" rel="stylesheet" />
  <link href="../assets/css/project.css" rel="stylesheet" />
</head>
<body class="project-page">
  <a class="monogram" href="../index.html#projects" title="Back">
    JS
  </a>

  <header class="hero container">
    <h1 class="title">TrackGraph Observability</h1>
    <p class="subtitle">Pulumi-Powered Telemetry & Delivery Platform</p>
  </header>

  <main class="container stack">
    <section class="section">
      <div class="section-block">
        <h2>Project Overview</h2>
        <p class="lead">
          TrackGraph Observability is the infrastructure-as-code backbone behind the TrackGraph web app.
          The stack provisions every AWS service needed for app delivery and end-to-end telemetry using Pulumi with Python.
          It deploys the production backend on App Runner, instruments it with OpenTelemetry, and funnels traces, metrics,
          and logs into managed observability services so feature work ships with real feedback loops.
        </p>
      </div>
    </section>

    <section class="section">
      <div class="section-block">
        <h2>Why Build an Observability Plane?</h2>
        <p class="lead">
          I wanted to treat the TrackGraph app like a production system: infrastructure defined in code,
          repeatable deployments, and telemetry that answers <em>why</em> something happened. Standing up an AWS-native stack
          forced me to learn how modern teams wire traces, metrics, and logs together, and how to validate that the data
          I'm collecting is trustworthy before anything breaks in production.
        </p>
      </div>
    </section>

    <section class="section two-col">
      <div class="section-block">
        <h2>Technologies Used</h2>
        <ul class="clean">
          <li>Pulumi (Python)</li>
          <li>AWS App Runner</li>
          <li>Amazon Managed Prometheus (AMP)</li>
          <li>Amazon Managed Grafana</li>
          <li>AWS Lambda & CloudWatch</li>
          <li>AWS CloudFront & S3</li>
          <li>AWS Secrets Manager</li>
          <li>OpenTelemetry / ADOT collectors</li>
          <li>GitHub Actions CI</li>
        </ul>
      </div>
      <div class="section-block">
        <h2>Key Outcomes</h2>
        <ul class="clean">
          <li>Containerized backend with trace instrumentation deployed via App Runner</li>
          <li>Prometheus metrics pipeline with managed collectors and Grafana dashboards</li>
          <li>Serverless log enrichment converting CloudFront logs into actionable metrics</li>
          <li>Repeatable Pulumi stack that mirrors production defaults but can target any AWS account</li>
        </ul>
      </div>
    </section>

    <section class="section">
      <div class="section-block">
        <h2>Stack Components</h2>
        <div>
          <p><strong>Backend Delivery:</strong> App Runner hosts the TrackGraph backend container, pulls secrets from AWS Secrets Manager, and scales on demand. OpenTelemetry auto-instrumentation ships traces directly to AWS X-Ray and the Prometheus collector plane.</p>
          <p><strong>Observability Plane:</strong> An App Runner ADOT sidecar and a Fargate-based collector scrape metrics, send them to Amazon Managed Prometheus, and expose them to a managed Grafana workspace for dashboards and alerting.</p>
          <p><strong>Data & Edge:</strong> Three S3 buckets separate static frontend assets, CloudFront logs, and Spotify data. A CloudFront distribution fronts the static site, while a Lambda function parses access logs into CloudWatch custom metrics that feed Grafana widgets.</p>
        </div>
      </div>
    </section>

    <section class="section">
      <div class="section-block">
        <h2>Repository Layout</h2>
        <ul class="clean">
          <li><code>__main__.py</code> wires together the component modules and exports stack outputs for other services.</li>
          <li><code>components/</code> contains custom Pulumi <code>ComponentResource</code> wrappers for storage, edge, backend, and observability.</li>
          <li><code>infra/</code> holds shared config helpers, optional prerequisite provisioning, and policy templates.</li>
          <li><code>collector-app-runner/</code> packages the ADOT proxy and collector config for the App Runner telemetry sidecar.</li>
          <li><code>lambda_fn/</code> includes the CloudFront log parser Lambda plus reusable parser and metrics libraries.</li>
          <li><code>tests/</code> runs pytest coverage over the log parser and metric publisher utilities.</li>
          <li><code>Pulumi.yaml</code> and <code>Pulumi.&lt;stack&gt;.yaml</code> define project metadata and per-env configuration (see the example template).</li>
        </ul>
      </div>
    </section>

    <section class="section two-col">
      <div class="section-block">
        <h2>Configuration & CI</h2>
        <p>
          Pulumi config keys live under the <code>trackgraph</code> namespace, mirroring production defaults so a new stack can launch with minimal overrides.
          GitHub Actions enforces formatting with Ruff, Black, and isort, runs pytest on the Lambda parser modules, and can execute a Pulumi preview
          whenever AWS credentials are supplied—never a blind <code>pulumi up</code> from CI.
        </p>
      </div>
      <div class="section-block">
        <h2>Observability Validation</h2>
        <ul class="clean">
          <li>Traces confirmed in AWS X-Ray once the App Runner backend comes online.</li>
          <li>Prometheus remote write verified through managed Grafana dashboards.</li>
          <li>CloudFront log ingestion triggers the Lambda and emits metrics in the <code>TrackGraph/CloudFront</code> namespace.</li>
        </ul>
      </div>
    </section>

    <section class="section">
      <div class="section-block">
        <h2>Demo</h2>
        <div class="slideshow" data-slideshow>
          <div class="slides">
            <div class="slide active">
              <figure>
                <div class="slide-frame">
                  <img src="../assets/ObservabilityDemo/obs1.png" alt="Pulumi stack graph highlighting backend and edge components" loading="lazy" />
                </div>
                <figcaption>Pulumi stack graph showing backend and edge resources wired for TrackGraph.</figcaption>
              </figure>
            </div>
            <div class="slide">
              <figure>
                <div class="slide-frame">
                  <img src="../assets/ObservabilityDemo/obs2.png" alt="Pulumi stack graph focusing on observability and storage resources" loading="lazy" />
                </div>
                <figcaption>Other half od the Pulumi stack graph.</figcaption>
              </figure>
            </div>
          </div>
          <div class="slideshow-controls">
            <button class="slideshow-button" type="button" data-action="prev" aria-label="Show previous slide">Previous</button>
            <span class="slideshow-status" aria-live="polite">1 / 2</span>
            <button class="slideshow-button" type="button" data-action="next" aria-label="Show next slide">Next</button>
          </div>
        </div>
      </div>
    </section>

    <section class="section">
      <div class="section-block">
        <h2>Project Details</h2>
        <div class="meta-grid">
          <div><strong>Timeline:</strong> Q4 2024 – Present</div>
          <div><strong>Team:</strong> Solo Project</div>
          <div><strong>Role:</strong> Infrastructure & Observability Engineer</div>
          <div><strong>Status:</strong> Stack deployed</div>
        </div>
      </div>
    </section>

    <section class="section">
      <div class="section-block">
        <p>Questions about the stack or telemetry approach? Reach out at <a href="mailto:josephsaldivarg@gmail.com">josephsaldivarg@gmail.com</a>.</p>
      </div>
    </section>

    <section class="section">
      <div class="section-block">
        <a class="btn" href="../index.html#projects">Back to Projects</a>
      </div>
    </section>
  </main>
  <div class="lightbox" data-lightbox role="dialog" aria-modal="true" aria-hidden="true">
    <figure class="lightbox-content">
      <button class="lightbox-close" type="button" data-lightbox-close>Close</button>
      <img data-lightbox-img alt="" />
      <figcaption data-lightbox-caption hidden></figcaption>
    </figure>
  </div>
  <script>
    (function () {
      const slideshows = document.querySelectorAll('[data-slideshow]');
      slideshows.forEach((slideshow) => {
        const slides = Array.from(slideshow.querySelectorAll('.slide'));
        const status = slideshow.querySelector('.slideshow-status');
        const prev = slideshow.querySelector('[data-action="prev"]');
        const next = slideshow.querySelector('[data-action="next"]');
        if (!slides.length || !prev || !next || !status) {
          return;
        }

        let index = slides.findIndex((slide) => slide.classList.contains('active'));
        if (index === -1) {
          index = 0;
        }

        const setActive = (newIndex) => {
          slides.forEach((slide, idx) => {
            slide.classList.toggle('active', idx === newIndex);
          });
          status.textContent = newIndex + 1 + ' / ' + slides.length;
        };

        prev.addEventListener('click', () => {
          index = (index - 1 + slides.length) % slides.length;
          setActive(index);
        });

        next.addEventListener('click', () => {
          index = (index + 1) % slides.length;
          setActive(index);
        });

        setActive(index);
      });

      const lightbox = document.querySelector('[data-lightbox]');
      if (lightbox) {
        const lightboxImg = lightbox.querySelector('[data-lightbox-img]');
        const lightboxCaption = lightbox.querySelector('[data-lightbox-caption]');
        const closeButtons = Array.from(lightbox.querySelectorAll('[data-lightbox-close]'));
        const primaryCloseButton = closeButtons[0] || null;
        let lastFocusedImage = null;

        const closeLightbox = () => {
          if (!lightbox.classList.contains('open')) {
            return;
          }
          lightbox.classList.remove('open');
          lightbox.setAttribute('aria-hidden', 'true');
          if (lightboxImg) {
            lightboxImg.removeAttribute('src');
            lightboxImg.alt = '';
          }
          if (lightboxCaption) {
            lightboxCaption.textContent = '';
            lightboxCaption.hidden = true;
          }
          if (lastFocusedImage) {
            lastFocusedImage.focus();
            lastFocusedImage = null;
          }
        };

        const openLightbox = (image) => {
          if (!lightboxImg) {
            return;
          }
          const figure = image.closest('figure');
          const captionText = figure && figure.querySelector('figcaption')
            ? figure.querySelector('figcaption').textContent.trim()
            : '';
          const source = image.currentSrc || image.src;

          lightboxImg.src = source;
          lightboxImg.alt = image.alt || '';
          if (lightboxCaption) {
            if (captionText) {
              lightboxCaption.textContent = captionText;
              lightboxCaption.hidden = false;
            } else {
              lightboxCaption.textContent = '';
              lightboxCaption.hidden = true;
            }
          }

          lastFocusedImage = image;
          lightbox.classList.add('open');
          lightbox.setAttribute('aria-hidden', 'false');
          if (primaryCloseButton) {
            primaryCloseButton.focus();
          }
        };

        const slideImages = document.querySelectorAll('.slide img');
        slideImages.forEach((img) => {
          const label = img.alt ? 'View larger: ' + img.alt : 'View larger image';
          img.setAttribute('tabindex', '0');
          img.setAttribute('role', 'button');
          img.setAttribute('aria-label', label);
          img.addEventListener('click', () => openLightbox(img));
          img.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
              event.preventDefault();
              openLightbox(img);
            }
          });
        });

        closeButtons.forEach((btn) => {
          btn.addEventListener('click', closeLightbox);
        });

        lightbox.addEventListener('click', (event) => {
          if (event.target === lightbox) {
            closeLightbox();
          }
        });

        document.addEventListener('keydown', (event) => {
          if (event.key === 'Escape' && lightbox.classList.contains('open')) {
            event.preventDefault();
            closeLightbox();
          }
        });
      }
    })();
  </script>
</body>
</html>
